# Git-Like Version Control System in C++: Comprehensive Project Documentation

## Introduction
Hey there! Welcome to my Git-like VCS project. I built this from scratch in C++ to understand how version control systems work under the hood. It's like Git but simplified, using basic data structures. This project helped me learn a ton about C++ file handling, memory management, and system design. Let's dive into the details!

## Project Overview
Imagine you're working on a big coding project with multiple files. You make changes, but sometimes you mess up and want to go back. That's where version control comes in. This VCS lets you:
- Track file changes
- Save snapshots (commits) of your work
- Go back to previous versions
- See history of changes

I implemented it using linked lists for commits, which is how Git stores history internally.

## Timeline of Development
I started this project by reading the plan.md file, which outlined the features. Here's how it went:

### Day 1: Planning and Setup
- Read plan.md and understood the requirements
- Created TODO.md to track progress
- Set up project structure: vcs_project/ with src/, include/, build/
- Thought: "I need to organize this well so it's easy to maintain"

### Day 2: Core Data Structures
- Created commit.h: Defined the Commit struct
- Problem: How to handle memory for linked list?
- Solution: Added destructor to clean up parent pointers
- Created repository.h: Class to manage VCS operations
- Thought: "Keep it simple but extensible"

### Day 3: Utility Functions
- Created utils.h and utils.cpp
- Implemented hashString() using std::hash
- Problem: Timestamp function returning empty on Windows
- Solution: Used std::ctime with nullptr check
- Added file I/O functions
- Thought: "These will be used everywhere, make them robust"

### Day 4: Main Logic
- Implemented repository.cpp: Core VCS methods
- Problem: Staging not persisting between runs
- Solution: Load/save staging in constructor/destructor
- Added commit serialization
- Thought: "Need to save state to disk properly"

### Day 5: CLI and Testing
- Created main.cpp for command parsing
- Built with CMake
- Tested init, add, commit, log
- Problem: Directory creation failing on Windows
- Solution: Used _mkdir with proper includes
- Thought: "Make it user-friendly"

### Day 6: Debugging and Polish
- Fixed hash generation issues
- Improved error handling
- Added more comments
- Final testing
- Thought: "It's working! Time to document"

## Detailed File Explanations

### Headers (include/)

#### commit.h
This file defines the basic building block of our VCS: the Commit.

```cpp
struct Commit {
    std::string hash;
    std::string message;
    std::string timestamp;
    std::vector<std::string> files;  // Files changed in this commit
    Commit* parent;  // Points to previous commit
};
```

Why this structure?
- Hash: Unique identifier (like Git's SHA-1)
- Message: User's description of changes
- Timestamp: When commit was made
- Files: Which files were modified
- Parent: Links to previous commit (linked list)

I added a constructor and destructor:
- Constructor: Initializes all fields
- Destructor: Cleans up memory to prevent leaks

Use case: Every time you commit, a new Commit object is created and linked to the previous one.

#### repository.h
This is the brain of the VCS. The Repository class handles all operations.

Key methods:
- init(): Creates .vcs directory
- add(file): Stages a file for commit
- commit(message): Saves staged changes
- log(): Shows commit history
- checkout(hash): Switches to a commit

Private helpers:
- generateCommitHash(): Creates unique hash
- saveCommit(): Writes commit to disk
- loadCommit(): Reads commit from disk

Why this design?
- Encapsulates all VCS logic
- Easy to extend with new features
- Handles file system interactions

#### utils.h
Helper functions that are used throughout the project.

Functions:
- hashString(): Simple hashing for commit IDs
- getCurrentTimestamp(): Gets current time
- readFile/writeFile(): File I/O
- fileExists(): Check if file exists

Why separate file?
- Reusable across modules
- Keeps main files clean
- Easy to test individually

### Source Files (src/)

#### main.cpp
The entry point. This is what users interact with.

It parses command line arguments:
- ./vcs init
- ./vcs add file.txt
- ./vcs commit -m "message"
- ./vcs log
- ./vcs checkout hash

Why simple parsing?
- No external libraries
- Easy to understand
- Sufficient for this project

#### repository.cpp
Implements the Repository class methods.

Key implementations:
- init(): Creates .vcs/commits/, .vcs/objects/ directories
- add(): Adds file to staging area (vector + file save)
- commit(): Creates Commit, generates hash, saves to disk
- log(): Traverses linked list, prints history
- checkout(): Loads commit, restores files

Problems faced:
1. Staging persistence: Initially lost between runs
   Solution: Save/load in constructor/destructor

2. Hash collisions: Rare but possible
   Solution: Include timestamp in hash data

3. Memory management: Linked list could leak
   Solution: Proper destructors

#### utils.cpp
Implements utility functions.

Notable implementations:
- hashString(): Uses std::hash<std::string>
- getCurrentTimestamp(): Uses std::ctime with safety checks
- File I/O: Uses fstream for reading/writing

Problems:
1. std::ctime returning nullptr on some systems
   Solution: Check for nullptr, return "Unknown time"

2. File paths: Windows vs Unix differences
   Solution: Used relative paths, handled in code

#### commit.cpp
Implements Commit struct methods.

Mainly constructor and destructor:
- Constructor: Sets message, files, parent
- Destructor: Deletes parent if needed (but careful with shared parents)

Why separate file?
- Keeps commit logic organized
- Easy to modify commit behavior

### Build System

#### CMakeLists.txt
Configures the build.

```cmake
cmake_minimum_required(VERSION 3.16)
project(VCS VERSION 1.0.0 LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 17)
include_directories(include)
add_executable(vcs src/main.cpp src/repository.cpp src/utils.cpp src/commit.cpp)
```

Why CMake?
- Cross-platform
- Handles dependencies
- Professional standard

## Problems Faced and Solutions

### 1. Timestamp Issues
Problem: getCurrentTimestamp() returned empty string on Windows.
Root cause: std::ctime might fail or return nullptr.
Solution: Added nullptr check:
```cpp
char* time_str = std::ctime(&now);
if (time_str) {
    // process
} else {
    return "Unknown time";
}
```

### 2. File Persistence
Problem: Staging area and HEAD lost when program restarted.
Root cause: Data only in memory.
Solution: Save to files in .vcs/ directory:
- staging: List of staged files
- HEAD: Current commit hash

### 3. Directory Creation
Problem: _mkdir() not working on Windows.
Root cause: Missing includes or wrong function.
Solution: Used CreateDirectoryA() or kept _mkdir with <direct.h>

### 4. Hash Generation
Problem: Needed unique commit hashes.
Solution: Hash combination of message, timestamp, files.
Used std::hash for simplicity (not cryptographically secure like Git's SHA-1).

### 5. Memory Management
Problem: Linked list commits could cause memory leaks.
Solution: Proper destructors, careful with parent pointers.

### 6. File Path Handling
Problem: Windows uses \ , Unix uses /.
Solution: Used relative paths, let C++ handle conversions.

## Step-by-Step Modifications

### Initial Setup
1. Created directory structure
2. Added CMakeLists.txt
3. Compiled empty project

### Adding Commit Structure
1. Created commit.h with basic struct
2. Added constructor/destructor
3. Tested compilation

### Repository Management
1. Created repository.h with method declarations
2. Implemented init() in repository.cpp
3. Added file system operations

### Utility Functions
1. Created utils.h declarations
2. Implemented in utils.cpp
3. Fixed timestamp issues

### CLI Interface
1. Created main.cpp with argument parsing
2. Added command handling
3. Integrated with Repository class

### Commit Logic
1. Implemented commit() method
2. Added hash generation
3. Saved commits to disk

### History and Checkout
1. Implemented log() to traverse commits
2. Added checkout() for switching versions
3. Fixed loading from disk

### Testing and Debugging
1. Manual testing of each command
2. Fixed persistence issues
3. Improved error messages

## How Users Use This VCS

### Basic Workflow
1. Initialize repository:
   ./vcs init

2. Add files to track:
   ./vcs add file1.txt
   ./vcs add file2.txt

3. Commit changes:
   ./vcs commit -m "Added new features"

4. View history:
   ./vcs log

5. Go back to previous version:
   ./vcs checkout <commit-hash>

### Creative Use Cases

#### 1. Personal Note Taking
Use it to version control your notes or journal. Each "commit" is a new entry.

#### 2. Configuration Management
Track changes to config files for servers or applications.

#### 3. Collaborative Writing
Writers can use it to track versions of documents, with meaningful commit messages.

#### 4. Code Experiments
Try different implementations, commit each approach, then compare.

#### 5. Backup System
Regular commits as backups of important files.

#### 6. Learning Tool
Study how version control works internally.

#### 7. Portfolio Project
Showcase C++ skills, data structures, file handling.

## Conclusion
This project taught me a lot about:
- C++ file system operations
- Memory management with pointers
- Linked list implementations
- Command-line interface design
- Problem-solving and debugging
- Version control internals

It's a solid foundation that could be extended with branches, merges, remote repositories, etc. The code is clean, commented, and demonstrates good C++ practices.

Total development time: About 6 days
Lines of code: ~500
Key technologies: C++17, CMake, Windows API
